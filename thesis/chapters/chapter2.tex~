%-*-coding: utf-8-*-

\chapter{Симуляция эволюции распределения}
\section{Примеры моделей и распределений}
\begin{figure}[ht]
  \begin{center}
    \subfigure[Композиция стандартных распределений для задания начального распределения]{%
        \putImgx{0.4\textwidth}{pic03-1}
        \label{simul:init}
    }
    \subfigure[Изменения распределения согласно модели случайного блуждания]{%
        \putImgx{0.4\textwidth}{pic03-4}
        \label{simul:after}
    }
  \end{center}
  \caption{Пример симуляции изменения распределения без маршрута}
\end{figure}

\FloatBarrier
\subsection{Разновидности начальных распределений}
Начальное распределение частиц фактически может быть представлено любой двумерной функцией,
интеграл которой по всей плоскости равен единице. Однако для большинства применений кажется
достаточным задание начального распределения как композиции стандартных двумерных распределений
(рис. \ref{simul:init}), таких как равномерное распределение в произвольной области или
 нормальное распределение задаваемое эллипсом, содержащим $3\sigma$ вероятности и тому подобное.
 Инструмент симуляции предоставляет удобный инструмент их задания.

На протяжении всей симуляции распределение хранится в текстуре (матрице). Значение, которое
записано в каждом пикселе, означает суммарный вес частиц, находящихся под этим пикселем,
если его нарисовать в мире. Пиксель текстуры имеет достаточно малый размер при рисовании в мире,
чтобы достаточно точно различать положения различных частиц, при этом достаточно большой,
чтобы текстура покрывающая всю вероятность влезла в память GPU, и ее обработка занимала
приемлемое время. \FloatBarrier
\subsection{Разновидности моделей изменения распределения}
Изменения распределений происходят с фиксированным временем дискретизации $\Delta t$.
Для симуляции изменений в большинстве моделей используется свертка с ядром с периодом $\Delta t$.

Процесс свертки с ядром осуществляется следующим образом, пусть $D_t, D_{t+\Delta t}$ ---
последовательные распределения, а $K$ --- ядро размера $(2k+1) \times (2k+1)$
(Пусть обращение к несуществующим элементам возвращает 0):

\begin{equation}
  D_{t+\Delta t}[i][j] = \sum\limits_{di=-k}^k \sum\limits_{dj=-k}^k D_t[i+di][j+dj] \cdot K[di][dj]
\end{equation}

Размер матрицы свертки выбирается такого размера, чтобы дать возможность симулировать
передвижение в произвольном направлении с достаточной точностью. На данный момент выбрано
значение $k = 5$.

Время $\Delta t$ выбирается исходя из размера ядра и физического размера пикселя.
Если размер пикселя $h \times h$, максимальная скорость перемещения объекта $v_{max}$,
тогда (\ref{eq:deltat}). 
\begin{equation}\label{eq:deltat}
  \Delta t = \frac {k \cdot h} {v_{max}}
\end{equation}

\begin{itemize}
\item{
\textbf{Модель случайных блужданий}

Простейший пример модели изменения распределения --- модель случайных блужданий
(рис. \ref{simul:after}). Ядро для модели случайных блужданий представляет собой матрицу со
значениями равными площади пересечения текущей ячейки с кругом, вписанным в квадрат размера
$2kh \times 2kh$. Ячейки соответствующим образом нормированы для равенства суммы единице.

Посредством изменения ядра (замены круга на кольца), можно изменять интенсивность блужданий.
}
\item{
\textbf{Модель движения в одном направлении}

Пусть заданы последовательности $\alpha_i, p_i, 1 \le i \le n$ --- углов и вероятностей
движения в направлении каждого из них. Для симулирования заданной модели можно
использовать $n$ экземпляров ядер и текстур для симуляции движения распределений
соответственно в каждом из направлений. На выходе для получения итогового распределения
достаточно скомбинировать полученные результаты с соответствующими весами $p_i$.
}
\item{
\textbf{Модель притяжения(отталкивания) к заданным точкам}

Иногда уместной оказывается модель избегания некоторых точек (например точек вблизи
текущей позиции поискового средства, если объект является вражеским и не желает быть
обнаруженным) или, напротив, приближения к ним (например в случае если объект знает ближайшее
положение суши, он может стремиться двигаться в ее направлении). Здесь 
удобно воспользоваться аналогией с электрическими зарядами, однако, действие электрических
сил для создания ускорения не кажется естественным в данной задаче. Значение функции
аналогичной силе Кулона будет задавать направление и скорость (вместо ускорения) движения
 при нахождении в данной точке. Таким образом каждая из точек имеет свой заряд $q_i$,
 позицию $pos_i$, радиус действия $R_i$ и закон убывания влияния, для примера используем
 Кулоновские $r^{-2}$. Пусть максимальная скорость перемещения объекта $v_{max}$.
Таким образом вектор скорости объекта в точке $p$ равен (\ref{eq:vqulon}).
\begin{equation}
  \chi_i(p) = 
  \left\{
    \begin{array}{ll}
      1 & \mbox{если } {(p - pos_i)^2 \le R_i} \\
      0 & \mbox{иначе }
    \end{array}
  \right.
\end{equation}

\begin{equation}
  v' = \sum\limits_{i=1}^n\frac{\chi_i(p) \cdot q_i \cdot (pos_i-p)} {|pos_i-p|^3} 
\end{equation}

\begin{equation}\label{eq:vqulon}
  v = min(|v'|, v_{max}) \cdot \frac {v'} {|v'|}
\end{equation}

При реализации данной модели, во время свертки ядро в каждой конкретной ячейке будет различным.
Таким образом приходится работать с текстурой скоростей из глобальной памяти вместо ядра в константной
памяти как в модели со случайными блужданиями, что в несколько раз замедляет время симуляции.
}
\end{itemize}
\FloatBarrier

\section{Процесс симуляции изменения распределения
 и прохождения маршрута}
\FloatBarrier
\subsection{Симуляция изменения распределения}
\drawfigurex{keyframe.png}{Схема применения частичных ядер}{pic:keyframe}{\textwidth}

Симуляция изменения распределения производится путем применения свертки текущего
распределения с ядром с промежутком времени $\Delta t_{frame}$. Если
$\frac {1} {\Delta t} \ge 60 FPS$, где $\Delta t$ --- время с которым необходимо применять
заданное ядро, тогда $\Delta t_{frame} = \Delta t$. Иначе время применения ядра слишком велико
и не обеспечивает необходимой динамичности.

Для обеспечения актуальной информации в промежутках между ключевыми кадрами, идущими с 
интервалом $\Delta t$, необходимо добавить $m$ промежуточных, так чтобы
$\Delta t_{frame} = \frac {\Delta t} {m + 1} \ge 60 FPS$. Таким образом из оригинального ядра
 $K_1$ нам необходимо получить $m$ промежуточных с некоторой точностью приближающих реальность 
$K_{\frac {1} {m+1}}, K_{\frac {2} {m + 1}}, ... , K_{\frac {m} {m + 1}}$. Посредством применения
заданных ядер к последнему ключевому кадру, будут получены приближенные распределения в 
промежуточные моменты времени (рис. \ref{pic:keyframe}), однако, полученные с помощью этих
 ядер текстуры не будут использованы для построения следующих, что избавляет симулятор 
от накопления погрешности от применения приближенных ядер.

Далее описан один из вариантов получения ядра $K_{\frac {i} {m + 1}}$, которой достаточно
хорошо демонстрирует себя на практике. Необходимо элементы ядра $K_{1}$ домножить на
$\alpha = 1 + c_0 - c_0^{\frac {i} {m+1}}$, где $c_0 = K_{1}[k][k]$, после чего добавить 
остаток $1 - \alpha$ к стационарной ячейке получившегося ядра $K_{\frac {i} {m + 1}}[k][k]$.
\FloatBarrier
\subsection{Симуляция сбора частиц средством поиска}
Сбор частиц производится с интервалом $\Delta t_{frame}$ в текстуре, соответствующей последнему
на данный момент ключевому кадру. После сбора к ключевому кадру применяются ядра,
рассчитывающие перемещение оставшихся частиц, для получения кадра, соответствующего
текущему времени.

Сбор частиц осуществляется посредством умножения значения каждого пикселя на долю его площади,
не покрытой зоной видимости ни в один из моментов времени в течении текущего интервала
$\Delta t_{frame}$. То есть подразумевается, что вес частицы распределен равномерно по площади
пикселя.

 Для получения суммарной зоны видимости во все моменты времени текущего интервала маршрут
средства поиска делится на прямолинейные участки. После чего на каждом участке берется объединение
$n = \beta \frac{dist}{r}$, взятых через равные промежутки, зон видимости, где $dist$ --- длина
прямолинейного участка, $r$ --- радиус видимости средства поиска, $beta$ --- коэффициент
точности края. Выбрано $\beta = 100$, что для всех разумных размеров текстур дает достаточно точные
края объединения зон видимости.

\FloatBarrier
\section{Корректировка области симуляции с течением времени}
\begin{figure}[ht]
  \centering
\begin{minipage}[t]{.48\textwidth}
  \centering
  \putImgx{\textwidth}{pic07-1}
  \captionof{figure}{Начальная область симуляции}
  \label{corr:1}
\end{minipage}
\begin{minipage}[t]{.48\textwidth}
  \centering
  \putImgx{\textwidth}{pic07-2}
  \captionof{figure}{Выход распределения за границы области, без корректировки}
  \label{corr:2}
\end{minipage}
\end{figure}
Одна из сторон прямоугольника $rect$, охватывающего интересующий район поиска, параллельна прямой
галсирования (в случае построения маршрутов стратегией ``Параллельное галсирование''). 
В начальный момент времени район задается вручную пользователем (рис. \ref{corr:1}).
Частицы, оказавшиеся снаружи начального района учитываться не будут.

Разрешение текстуры выбирается таким образом, чтобы размер пикселя был квадратным
(при необходимости немного изменяется выбранный район для симуляции), а количество пикселей
было максимально возможным, при котором можно обеспечить приемлемую производительность.
Сейчас выбрано количество пикселей порядка $800^2 = 6.4 \cdot 10^5$.

С течением времени рассматриваемые частицы могут выходить за пределы текущего рассматриваемого
района. Без корректировки района информация о местоположении этих частиц будет потеряна
(рис. \ref{corr:2}).

\begin{figure}[ht]
  \centering
\begin{minipage}[t]{.48\textwidth}
  \centering
  \putImgx{\textwidth}{pic07-3}
  \captionof{figure}{Приближение распределения к границе области симуляции}
  \label{corr:3}
\end{minipage}
\begin{minipage}[t]{.48\textwidth}
  \centering
  \putImgx{\textwidth}{pic07-4}
  \captionof{figure}{Изменение центра области симуляции согласно новому положению распределения}
  \label{corr:4}
\end{minipage}
\end{figure}

Корректировка рассматриваемого района осуществляется, когда в одном из пикселей на границе
шириной $2k$, где $k$ --- параметр ядра, находятся частицы с суммарным весом более $\epsilon$.
(рис. \ref{corr:3}) В реализации выбрано $\epsilon = 5 \cdot 10^{-3}$.

Для корректировки находится прямоугольник $rect$, охватывающий все пиксели суммарный вес в которых
больше $\epsilon$, причем длина и ширина прямоугольника содержат четное число пикселей.
После чего выделяется новая текстура с центром, совпадающим с центром полученного прямоугольника
(рис. \ref{corr:4}) (благодаря четности, стороны пиксели новой и старой текстуры выровнены), 
после чего данные копируются в новую текстуру.

Так как разрешение новой текстуры всегда остается прежним, возможно необходимо увеличить
прямоугольник покрываемый текстурой для покрытия прямоугольника $rect$. Размер покрываемого
прямоугольника последовательно увеличивается в два раза, равномерно расширяясь относительно центра,
до тех пор пока не покроет прямоугольник $rect$, (рис. \ref{corr:5}) после чего его положение
немного корректируется, чтобы в каждый новый пиксель (если увеличили в $2^m$ раз) попало ровно
$2^{2m}$ целых старых пикселей.

\begin{figure}[ht]
  \centering
    \putImgx{0.8\textwidth}{pic07-5}
    \caption{Расширение и измененеие центра области симуляции}
    \label{corr:5}
\end{figure}

\section{Статистика прохождения маршрута}
\begin{figure}[ht]
  \centering
    \putImgx{\textwidth}{pic08-2}
    \caption{Окно с отображением статистики}
    \label{stat:0}
\end{figure}

Симулятор предоставляет статистику о прохождении маршрута, по которой строятся графики
прогресса поиска и поисковой производительности. Оба графика отображают зависимости
от времени, поэтому изображены в одном окне с разными шкалами по оси ординат. (рис. \ref{stat:0})

Прогресс поиска (красный график) --- отображает текущий суммарный вес собранных частиц
в процентах от общего веса в начальный момент времени.

Поисковая производительность (синий график) --- отображает текущую эффективность поиска.
Фактически является производной прогресса поиска по времени, однако также измеряется
в процентах. Поисковая производительность $x\%$ --- означает, что если мы будет искать
с такой поисковой производительностью в течении всего времени поиска $t_{search}$,
то сможем собрать $x\%$ веса частиц. 

\FloatBarrier
