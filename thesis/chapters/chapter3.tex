%-*-coding: utf-8-*-
\chapter{Алгоритм построения маршрутов согласно стратегии
``Параллельное галсирование''}
\section{Алгоритм построения маршрута при
 фиксированном распределении}

\def\dprule{ \rule[-2ex]{0pt}{4ex} }

Для построения маршрута в случае сохранения частицами их положений будет использован метод
динамического программирования. Далее будут описаны состояния алгоритма, его переходы и
вспомогательные значения, посчитанные на матрице распределения.

Прежде всего введем сетку на прямоугольнике на котором рассматривается распределение.
Пусть размер сетки будет $H \times W$, размеры ячеек будут одинаковыми, но не обязаны
быть квадратными или выровненными по пикселям текстуры. В частности мы будем стремиться
к очень высокому разрешению по строчкам для более точного определения расстояния между
соседними галсами и нам будет достаточно небольшого разрешения по столбцам. Например,
если размеры текстуры $T_H \times T_W$, а размеры прямоугольника в мире $R_H \times R_W$,
то мы хотим иметь размеры сетки $H = T_H$ и $W \approx \frac {R_w} {1000}$.

\subsection{Состояния алгоритма}
Значением динамического программирования $dp(state)$ для определенного состояния будет
суммарный вес собранных частиц к моменту времени определяемому состоянием. На самом деле
храниться будет весь суммарный весь за исключением покрытого лишь передним полукругом
текущего положения. 

Состоянием динамического программирования является кортеж $(cntHor, row, col, move, notCleared)$.
\begin{itemize}
\item $(row, col)$ --- строка и столбец ячейки в которой закончен маршрут к текущему моменту времени
соответственно.
\item $cntHor$ --- количество горизонтальных перемещений (между столбцами). Если обозначить
за $time_W$ --- время перемещения между двумя соседними ячейками по горизонтали, а за $time_H$ ---
по вертикали, то текущее время можно посчитать как $curTime = time_H \cdot row + time_w \cdot cntHor$.
Здесь использованы предположения, что средство поиска никогда не возвращается назад по строчками
(исходя из выбранной стратегии поиска), всегда двигаемся с максимальной скоростью и в начальный
момент времени находится в нулевой строке.
\item $move$ --- тип текущего хода (который завершится в этом состоянии). Принимает значение 
из множества $\{L, R, LU, RU\}$. $L/R$ --- означает, что мы галсируем в текущей строчке влево или
вправо соответственно (галсировать  в обе стороны в одной строчке нельзя). 
$LU/RU$ --- означает, что мы поднимаемся по строчкам, причем в последней строчке в которой мы
галсировали мы двигались влево или вправо соответственно. Уточнение в какую сторону мы двигались
последний раз необходимо для более точного учета собранных нами частиц во время подъема по строчкам.
\item $notCleared$ --- количество пропущенных строк без галсирования. Главное предположение,
позволяющее значительно сократить количество состояний, состоит в том, что для понимания
какие из частиц еще не были собраны в текущей полосе галсирования,
нам достаточно знать когда был предыдущий галс или другими словами сколько строк мы пропустили без
галсирования. Зная какие из частиц не собраны, мы сможем рассчитать сколько частиц мы соберем
в текущий момент прохождения маршрута. Данный параметр принимает $N$ значений. $0$ означает,
что мы галсировали прямо в предыдущей строчке, $(N-1)$ --- последний раз мы галсировали $N$ строк
назад либо еще дальше. $N$ выбирается таким образом, чтобы галсирование $N$ строк назад
не оказывало значительного влияния на текущее.
\end{itemize}

\subsection{Вспомогательные матрицы с частичными суммами весов}
Обозначим радиус зоны видимости средства поиска за $r$. Обозначим функции, переводящие
из системы координат построенной сетки в мировую систему координат, за $w_x(col), w_y(row)$.

Предположим, что вес частиц в каждом пикселе распределен равномерно. Тогда с помощью
сумм на префиксе, построенных на текстуре за время $O(T_W \cdot T_H)$, можно за $O(1)$
отвечать на запросы вида сумма на прямоугольнике $[x_l ; x_r] \times [y_l ; y_r]$.
При вычислении суммы используется линейная интерполяция на пикселях частично попавших
в прямоугольник запроса.

\drawfigurex{dpzones}{Типы зон при прохождении маршрута}{dpzones}{0.5\textwidth}

Для подсчета веса частиц, собранных при прохождении маршрута, маршрут будет разделен на
части разного типа (рис. \ref{dpzones}). Как видно из картинки некоторые части могут
быть частично учтены ранее, поэтому важно знать значение $notCleared$ --- сколько строк
было пропущено без галсирования. Таким образом все предпосчитанные матрицы будут возвращать
значения с учетом $notCleared$. Самое большое значение $notCleared$ равное $N-1$ будет
использовано также в случаях, когда требуется считать, что последний галс был
достаточно далеко, чтобы не оказывать никакого влияния в текущем положении.

Для примера рассмотрен переход между двумя галсами, содержащий части всех возможных типов.
В примере ширина ячейки в два раза больше ее высоты. Примеры ячеек сетки динамики 
изображены красными прямоугольниками. Красная точка в центре 
ячейки сетки обозначает положения средства поиска при нахождении в этом состоянии динамики.
Для упрощения пусть точка с координатами $(row, col)$ совпадает с центром соответствующей ячейки.
Тогда область определения $w_x \in [-0.5; M-0.5]$, а $w_y \in [-0.5; N-0.5]$.
Желтым отмечен маршрут. Разные типы частей помечены различными цветами. Черная сетка на
фоне может интерпретироваться как сетка пикселей.

Рассмотрим вертикальные части синего цвета. Значение матрицы $vl[row][col][notCleared]$
будет содержать сумму в прямоугольнике
$[w_x(col-1), w_x(col)] \times [w_y(row)-r, w_y(row)+r]$. Без 
учета частиц собранных ниже прямой $w_y(row-1-notCleared) + r$. А $vr[row][col][notCleared]$
будет содержать $[w_x(col), w_x(col+1)] \times [w_y(row)-r, w_y(row)+r]$.

Розовый и оранжевый тип отличаются лишь положением относительно маршрута, справа или слева
соответственно. Матрица для оранжевого 
$hl[row][col][notCleared]$ содержит сумму в
$[w_x(col)-r, w_x(col)] \times [w_y(row-1), w_y(row)]$. Матрица для розового
$hr[row][col][notCleared]$ содержит $[w_x(col), w_x(col)+r] \times [w_y(row-1), w_y(row)]$.

Обратим внимание на область, покрытую одновременно оранжевым и синим цветом в верхней части картинки.
До тех пор пока мы не повернули налево для прохождения нового галса --- эта область будет
учтена как область оранжевого типа. После поворота она будет переучтена как область синего.
Для исключения первого, ошибочно посчитанного раза необходимо предпосчитать
матрицу $ol[row][col][notCleared]$ --- область $[w_x(col)-r, w_x(col)] \times [w_y(row)-r, w_y(row)]$
и матрицу $or[row][col][notCleared]$ --- область $[w_x(col),w_x(col)+r]\times [w_y(row)-r, w_y(row)]$.

Последним типом являются четверти круга (зеленый цвет), которые должны быть учтены при поворотах.
Суммарный вес под ними будет хранить матрица $cs[row][col][quarter][notCleared]$.
$quarter$ --- обозначает четверть и будет принимать значения $Q_{RU}, Q_{LU}, Q_{LD}, Q_{RD}$
соответственно для четвертей в порядке их стандартной нумерации. Для вычисления суммарного
веса, находящегося под четвертью круга, используется численное интегрирование посредством
вычисления сумм на прямоугольниках.
\FloatBarrier
\subsection{Переходы между состояниями}
Переходы из состояния динамики \[state=(cntHor, notCleared, row, col, curMove)\] будут
описаны в таблице \ref{table:dp} следующим образом. Текущий ход
$curMove$ будет зафиксирован в первом столбце, следующий выбранный во втором.
$newState$ --- состояние в которое мы перейдем, выбрав такой ход, указано
в четвертом столбце. Все величины, которые нужно добавить при переходе
к величине $dp(state)$ перед релаксацией значения $dp(newState)$ указаны
в третьем столбце. Если обозначить эти величина за $a_i, i \in 1..k$, то более
формально $dp(newState) = min(dp(newState), dp(state) + \sum_{i=1}^{k} a_i)$.
\begin{table}[ht]
  \centering
\begin{tabular}{|l|l|l|l|}
  \hline
  Текущий & Следующий & Собрано на текущем ходу & Новое состояние  \\
  ход & ход & & \\
\hline 
\dprule $L$&$L$&$vr[row][col-1][notCleared]$&$(cntHor+1,notCleared,row,col-1,L)$\\
\hline 
\dprule $L$&$LU$&$hl[row+1][col][N-1]$&$(cntHor,0,row+1,col,LU)$\\
\dprule  && $hr[row+1][col][0]$ & \\
\dprule  && $cs[row][col][Q_{LD}][notCleared]$ & \\
\hline 
\dprule $R$&$R$&$vl[row][col+1][notCleared]$&$(cntHor+1,notCleared,row,col+1,R)$\\
\hline 
\dprule $R$&$RU$&$hr[row+1][col][N-1]$&$(cntHor,0,row+1,col,RU)$\\
\dprule  && $hl[row+1][col][0]$ & \\
\dprule  && $cs[row][col][Q_{RD}][notCleared]$ & \\
\hline 
\dprule $LU$&$LU$&$hl[row+1][col][N-1]$&$(cntHor,notCleared+1,row+1,col,LU)$\\
\dprule && $hr[row+1][col][notCleared+1]$ & \\
\hline 
\dprule $LU$&$L$&$vr[row][col-1][notCleared]$&$(cntHor+1,notCleared,row,col-1,L)$\\
\dprule && $cs[row][col][Q_{RU}][notCleared]$ & \\
\dprule && $-ol[row][col][notCleared]$ & \\
\hline 
\dprule $LU$&$R$&$vl[row][col+1][notCleared]$&$(cntHor+1,notCleared,row,col+1,R)$\\
\dprule  && $cs[row][col][Q_{LU}][N-1]$ & \\
\dprule && $-or[row][col][notCleared]$ & \\
\hline 
\dprule $RU$&$RU$&$hr[row+1][col][N-1]$&$(cntHor,notCleared+1,row+1,col,RU)$\\
\dprule && $hl[row+1][col][notCleared+1]$ & \\
\hline 
\dprule $RU$&$L$&$vr[row][col-1][notCleared]$&$(cntHor+1,notCleared,row,col-1,L)$\\
\dprule && $cs[row][col][Q_{RU}][N-1]$ & \\
\dprule && $-ol[row][col][notCleared]$ & \\
\hline 
\dprule $RU$&$R$&$vl[row][col+1][notCleared]$&$(cntHor+1,notCleared,row,col+1,R)$\\
\dprule && $cs[row][col][Q_{LU}][notCleared]$ & \\
\dprule && $-or[row][col][notCleared]$ & \\
\hline 
\end{tabular}
\captionsetup{justification=centering}
\caption{Переходы из состояния $(cntHor,notCleared,row,col,curMove)$}
\label{table:dp}
\end{table}
\FloatBarrier
\subsection{Оценка времени работы}
Оценим количество операций для построения вспомогательных матриц. Подсчет значений в матрицах
$hl, hr, ol, or, vl, vr$ можно осуществить за $O(1)$ операций, если предпосчитать префикс
суммы на текстуре за $O(T_W \cdot T_H)$. Количество значений в каждой из этих матриц
$O(W \cdot H \cdot N)$ или при грубой оценке $N$ --- $O(W \cdot H^2)$.

Из каждого состояния динамики осуществляется $O(1)$ переходов, таким образом для оценки
времени работы алгоритма достаточно посчитать количество состояний. Если обозначить
за $T = \frac {t_{search}} {time_W}$, то количество состояний составит $O(T \cdot W \cdot H \cdot N)$.
Однако в большинстве случаев время достаточное для обследования всей территории с вероятностью
близкой к 100\% составляет $W \cdot \frac {H} {N}$.  Таким образом количество состояний
составит $O(W^2 \cdot H^2)$.

Максимальную точность позволяет получить значение $H \approx T_H$, однако на практике оказывается
достаточным $H = \frac {T_H} {4}$, что также позволяет алгоритму работать достаточно быстро.

На практике достижимых состояний оказывается втрое меньше их общего числа. Одна из причин
этого то, что не имеет смысла проводить больше времени чем нужно на каком-либо префиксе
пути. Если все частицы на этом префиксе можно собрать за определенное время $\tau$, состояния,
которые тратят больше времени, оказываются лишними. Вторая причина противоположная --- до некоторых
положений невозможно дойти за время меньше некоторого определенного.
\section{Корректировка маршрута}
\begin{figure}[ht]
  \centering
\begin{minipage}[t]{.4\textwidth}
  \centering
  \putImgx{\textwidth}{pic02-init}
  \captionof{figure}{Маршрут построенный на начальном распределении}
  \label{algo:init}
\end{minipage}
\begin{minipage}[t]{.4\textwidth}
  \centering
  \putImgx{\textwidth}{pic02-before}
  \captionof{figure}{Маршрут оказался неудовлетворительным с течением времени}
  \label{algo:before}
\end{minipage}
\end{figure}

Вернемся к изначальной постановке задачи, когда частицы могут изменять свое местоположение
согласно некоторой модели. На рис. \ref{algo:init} изображен маршрут, построенный
рассмотренным алгоритмом. Изменение распределения следует комбинации моделей случайного
блуждания и приближения к вертикальной прямой (берегу), находящейся слева от распределения.
Таким образом к середине прохождения маршрута становится заметно (рис. \ref{algo:before}), что
положения частиц изменились настолько, что текущий планируемый маршрут оказался неудовлетворительным.

Предлагаемым решением является перестройка оставшейся части маршрута (рис. \ref{pic02-after})
в момент времени когда становится понятно, что текущий маршрут не получит достаточного
суммарного веса.

\drawfigurex{pic02-after}{Оставшаяся часть маршрута была перестроена}{pic02-after}{0.4\textwidth}

Рассмотрим критерий необходимости перестройки маршрута в момент времени $t_i$, если последний
раз маршрут перестраивался в момент времени $t_{i-1}$. Разделим построенный
маршрут на две части: $path_{t_{i-1} \le t \le t_{i}}$ --- уже пройденная часть маршрута, $path_{\ge t_{i}}$
--- запланированная часть маршрута. Далее рассмотрим два симулятора прохождения маршрута в которых
частицы не изменяют своего местоположения со временем. Симулятор $D_0$ содержит распределение
в момент времени $t_{i-1}$ на котором был просимулирован маршрут $path_{t_{i-1} \le t \le t_{i}}$.
Симулятор $D_1$ содержит распределение в момент времени $t_i$. На каждом из симуляторов оценивается
суммарный вес, который будет собран на маршруте $path_{\ge t_{i}}$. Пусть это будут величины
$sum_0$ и $sum_1$ соответственно. Маршрут должен быть перестроен в случае, если
 $sum_1 \le p \cdot sum_0$. В реализации выбрано значение $p = 0.98$.

Данный критерий корректировки, как будет показано далее, позволяет достаточно успешно корректировать
маршрут для сбора достаточного веса частиц при активно изменяющемся положении частиц.

\FloatBarrier

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
